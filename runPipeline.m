%{
processICsweepsParFor
- analysis of intracellular hyperpolarizing and depolarizing sweeps
%}
clear

mainFolder = 'D:\output_MATNWB\';            % main folder (EDIT HERE)
start = 11;
outDest = 'D:\output_MATNWB\QC\';                                          % general path
cellList = dir([mainFolder,'*.nwb']);                                      % list of cell data files
BwSweepMode = 2;                                                           % NeuroNex = 1, Choline macaque = 2
params = loadParams;                                                       % load parameters to workspace

%% Set to overwrite or delete nwb files from output folder 

overwrite = 0;
if length(mainFolder) == length(outDest) && mainFolder == outDest
    overwrite = 1;
else    
    for k = 1 : length(cellList)
      baseFileName = cellList(k).name;
      fullFileName = fullfile(outDest, baseFileName);
      fprintf(1, 'Now deleting %s\n', fullFileName);
      delete(fullFileName);
    end
    clear fullFileName baseFileName
end    

%% Initialize feature and QC summary tables

temp = {cellList.name};
temp = cellfun(@(S) S(1:end-4), temp, 'Uniform', 0);
features = {...
    'Vrest' 'resistance' 'tau' 'Rheo' 'sag' 'sag_ratio' 'sagAmp' ...
    'widthTP_LP' 'peakLP' 'thresholdLP' 'fastTroughLP' 'slowTroughLP' ...
    'peakUpStrokeLP' 'peakDownStrokeLP' 'peakStrokeRatioLP' 'heightTP'...
    'latency' 'medInstaRate' 'maxFiringRate' };

ICsummary = array2table(NaN(length(cellList),length(features)), ...
    'VariableNames', features,'RowNames', temp);

qc_tags = {'SweepsTotal' 'QC_total_pass' 'stRMSE_pre' 'stRMSE_post' ...
        'ltRMSE_pre' 'ltRMSE_post' 'diffVrest' ...
        'Vrest'  'holdingI' 'betweenSweep' ...
        'bridge_balance_abs' 'bridge_balance_rela' 'bad_spikes' ...
         };

QC_removalsPerTag = array2table(NaN(length(cellList),length(qc_tags)), ...
    'VariableNames', qc_tags,'RowNames', temp);

QCparameterTotal = struct();

%% Looping through nwb files
for n = start:length(cellList)                                             % for all cells in directory
    cellID = cellList(n).name(1:length(cellList(n).name)-4);               % cell ID (used for saving data)
    disp(cellID)                                                           % display ID number
    cellFile = nwbRead([mainFolder,cellList(n).name]);                     % load nwb file
   
    %% Initialize processing moduls   
    module_spikes = types.core.ProcessingModule(...
             'description','AP processing',...
             'dynamictable', []  ...
                   );
               
    module_subStats = types.core.ProcessingModule(...
         'description', 'subthreshold parameters',...
         'dynamictable', []  ...
               );
           
    module_ISIs = types.core.ProcessingModule(...
                         'description', 'Table with ISIs per sweep',...
                         'dynamictable', []  ...
                               );    
    module_QC = types.core.ProcessingModule(...
                         'description', 'Table with QC parameter',...
                         'dynamictable', []  ...
                               );     
        
    %% Initialize QC columns and adding them to the sweep table
     new_sweep_table_descriptions = {...
         'Binary for total QC evaluation of sweep; pass = 1, fail=0'
         'Binary for short-term root mean sqaure evaluation of prestimulus interval; pass = 1, fail=0'
         'Binary for short-term root mean sqaure evaluation of poststimulus interval; pass = 1, fail=0'
         'Binary for long-term root mean sqaure evaluation of prestimulus interval; pass = 1, fail=0'
         'Binary for long-term root mean sqaure evaluation of poststimulus interval; pass = 1, fail=0'
         'Binary for QC evaluation of voltage difference between pre and post stimulus intervall; pass = 1, fail=0'
         'Binary for QC evaluation of prestimulus membrane potential; pass = 1, fail=0'
         'Binary for QC evaluation of absolute bridge balance value; pass = 1, fail=0'
         'Binary for QC evaluation of relative bridge balance value; pass = 1, fail=0'
         'Binary for QC evaluation of holding current value; pass = 1, fail=0'
         'Binary for QC evaluation of across sweep variability (i.e. drift) of the prestimulus membrane potential; pass = 1, fail=0'
         'Binary for QC evaluation of sweeps with bad spike wave forms; pass = 1, fail=0'
         };
     
    for t = 2:length(qc_tags)
        cellFile.general_intracellular_ephys_sweep_table.colnames{t+1} = ...
            qc_tags{t};
        cellFile.general_intracellular_ephys_sweep_table.vectordata.map(qc_tags{t}) = ...
          types.hdmf_common.VectorData(...
           'description', new_sweep_table_descriptions{t-1},...
           'data', zeros(...
              cellFile.general_intracellular_ephys_sweep_table.sweep_number.data.dims,1)...
              );   
    end
    
    %% Adding colum for sweep amplitudes, stimulus onset and end
    
    if ~cellFile.general_intracellular_ephys_sweep_table.vectordata.isKey('SweepAmp')
      cellFile.general_intracellular_ephys_sweep_table.vectordata.map(...
        'SweepAmp') = ...
          types.hdmf_common.VectorData(...
           'description', 'amplitdue of the current step injected (if square pulse)',...
           'data', zeros(...
              cellFile.general_intracellular_ephys_sweep_table.sweep_number.data.dims,1)...
              ); 
          
              cellFile.general_intracellular_ephys_sweep_table.vectordata.map(...
        'StimOn') = ...
          types.hdmf_common.VectorData(...
           'description', 'Index of stimulus onset',...
           'data', zeros(...
              cellFile.general_intracellular_ephys_sweep_table.sweep_number.data.dims,1)...
              );   
              
              cellFile.general_intracellular_ephys_sweep_table.vectordata.map(...
        'StimOff') = ...
          types.hdmf_common.VectorData(...
           'description', 'Index of end of stimulus',...
           'data', zeros(...
              cellFile.general_intracellular_ephys_sweep_table.sweep_number.data.dims,1)...
              );   
    end
    %% Setting up two QC tables
    QC_parameter = array2table(NaN(...
               length(cellFile.acquisition.keys), length(qc_tags)-1));            
    QC_parameter.Properties.VariableNames = ['SweepID', qc_tags(3:end)];    
    QC_parameter.SweepID = string(QC_parameter.SweepID);
    QCpass =  QC_parameter;
    %% Initializing Variables 
    ISIs = {}; SpQC = struct();
    SweepCount = 1;  subCount = 1; supraCount = 1;   
    sagSweep= []; RheoSweep = [];
    %% Looping through sweeps 
    SweepPathsAll = {cellFile.general_intracellular_ephys_sweep_table.series.data.path};
    SweepPathsStim = {SweepPathsAll{find(contains(SweepPathsAll,'stimulus'))}};
    SweepPathsAqui = {SweepPathsAll{find(contains(SweepPathsAll,'acquisition'))}};
   
    for s = 1:length(SweepPathsStim)                      % loop through sweeps        

        CurrentPath = cell2mat(SweepPathsStim(s));
        CurrentName = CurrentPath(find(CurrentPath=='/',1,'last')+1:length(CurrentPath));        
        [QC_parameter.SweepID(SweepCount), QCpass.SweepID(SweepCount)] = ...
          deal(string(CurrentName));
        
        CCStimSeries = cellFile.resolve(SweepPathsStim(s));
        
        idx = find(cellFile.general_intracellular_ephys_sweep_table.sweep_number.data.load== ...
                CCStimSeries.sweep_number);
        
        CCSeries = cellFile.resolve(...
             cellFile.general_intracellular_ephys_sweep_table.series.data(idx(2)).path);
         
        if CCStimSeries.data.dims/CCStimSeries.starting_time_rate > 0.25 &&...
            ~contains(CCStimSeries.stimulus_description, 'Ramp') &&...
             ~contains(CCStimSeries.stimulus_description, 'Short') 
                         
            if ~cellFile.general_intracellular_ephys_sweep_table.vectordata.isKey('StimOn')
              [StimOn,StimOff] = GetSquarePulse(CCStimSeries.data);     

              if isempty(StimOn) || StimOff/CCStimSeries.starting_time_rate < 0.1
                 display(['No input current detected in ', char(SweepPathsStim(s))])
    %                    StimOn = CCStimSeries.data.dims/3;
    %                    StimOffset = 2*CCStimSeries.data.dims/3;              
              end    

              if ~isa(CCSeries, 'types.core.IZeroClampSeries')
                 [QC_parameter, QCpass] = SweepwiseQC(CCSeries, ...
                                       StimOn, SweepCount,QC_parameter, ...
                                               QCpass, params);
              else
                  SweepCount = SweepCount-1;  
              end    

              sweepAmp = mean(CCStimSeries.data.load(StimOn:StimOff));
              cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    4}.data(idx) = sweepAmp;

              if ~isempty(StimOn)
                   cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    3}.data(idx) = StimOn;
                   cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    2}.data(idx) = StimOff;
              end

           else
                StimOn = unique(cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    3}.data(idx));
                StimOff = unique(cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    2}.data(idx));
                sweepAmp = unique(cellFile.general_intracellular_ephys_sweep_table.vectordata.values{...
                    4}.data(idx));
            end

            [QC_parameter, QCpass]  = SweepwiseQC(CCSeries, StimOn, ...
                                   SweepCount, QC_parameter, QCpass, params);

             if sweepAmp > 0                                                                % if current input > 0

                      [module_spikes, sp, SpQC, QCpass] = ...
                         processSpikes(CCSeries, StimOn, StimOff, params, ...
                                         supraCount, module_spikes, SpQC, ...
                                           QCpass, SweepCount, CurrentName);
                       supraCount = supraCount + 1;

                       if ~isempty(sp)
                         [spTrain, ISIs] = ...
                             estimateAPTrainParams(sp,StimOn,CCSeries,...
                                                         supraCount, ISIs);
                       end

               elseif sweepAmp < 0 
                       module_subStats = subThresFeatures(CCSeries,...
                                              StimOn, StimOff, sweepAmp, ...
                                               CurrentName, module_subStats, params);
                       subCount = subCount +1;
               end
               SweepCount = SweepCount + 1;    
        end
    end
   %% save AP wave and subthreshold parameters
   cellFile.processing.set('subthreshold parameters', module_subStats);
   cellFile.processing.set('AP wave', module_spikes);

   %% QC bridge balance relative to input resistance
   Ri_preqc = inputResistance(module_subStats.dynamictable);
   QCpass.bridge_balance_rela = ...
       QC_parameter.bridge_balance_rela < Ri_preqc*params.factorRelaRa;
   
   %% Between Sweep QC
   [BwSweepPass, BwSweepParameter] = BetweenSweepQC(...
                                        QC_parameter, BwSweepMode, params);
   QCpass.betweenSweep = BwSweepPass;
   QC_parameter.betweenSweep = BwSweepParameter;
   
   %% save SpikeQC in ragged array    
   [data_vector, data_index] = create_indexed_column(ISIs, 'path');
   ISI_table = types.hdmf_common.DynamicTable(...
                    'colnames', 'ISIs',...
                    'description', 'ISI table',...
                    'id', types.hdmf_common.ElementIdentifiers('data', ...
                                           [0:length(data_vector.data)]) ,...
                    'ISIs', types.hdmf_common.VectorData(...
                                            'data', data_vector.data,...
                                            'description', 'Interspike Intervals'...
                                        ),...
                    'ISIs_index', types.hdmf_common.VectorIndex(...
                                            'data', data_index.data,...
                                            'target', types.untyped.ObjectView(...
                                              '/processing/All_ISIs/ISI_table/ISIs')...
                                                  )...
                                                    );
   module_ISIs.dynamictable.set('ISI_table', ISI_table);      
   cellFile.processing.set('All_ISIs', module_ISIs); 
      
   %% Save QC results in Sweeptable and external 
   
   QC_parameter = rmmissing(QC_parameter);
   QCpass = rmmissing(QCpass,'MinNumMissing',2);
   QCparameterTotal.(['AI_' cellID ]) = QC_parameter;
   
   QCpass.bad_spikes(isnan(QCpass.bad_spikes)) = 1; 
   QC_parameter.SweepID = char(QC_parameter.SweepID);
   table = table2nwb(QC_parameter, 'QC parameter table');  
   module_QC.dynamictable.set('QC_parameter_table', table);
   cellFile.processing.set('QC parameter', module_QC);
    
   for t = 5:cellFile.general_intracellular_ephys_sweep_table.vectordata.Count      %loop trhough QC pass columns in sweep table
     key = cellFile.general_intracellular_ephys_sweep_table.vectordata.keys{t};     
     cellFile.general_intracellular_ephys_sweep_table.vectordata.values{t}.data =  ...
       QCpass.(key);                                                                    % fill with the respective value   
   end
   
   for s = 1:height(QCpass)
              
        SweepPos = endsWith(SweepPathsAll,QCpass.SweepID(s));            
        
        if sum(table2array(getRow(...
            cellFile.general_intracellular_ephys_sweep_table,...
              s,'columns', qc_tags(3:end)))) == 11

           cellFile.general_intracellular_ephys_sweep_table.vectordata.values{1}.data(SweepPos) = true; 
        else       
           cellFile.general_intracellular_ephys_sweep_table.vectordata.values{1}.data(SweepPos) = false;       
        end 
   end
   
   temp = varfun(@sum, QCpass(:,2:end));
   QC_removalsPerTag(n,3:end) = num2cell(-(temp{:,:}-height(QCpass)));
   QC_removalsPerTag(n,2) = {sum(...
     cellFile.general_intracellular_ephys_sweep_table.vectordata.values{1}.data(...
       1:length(SweepPathsAqui)))};
   QC_removalsPerTag(n,1) = {height(QCpass)};
   
   %% save ISIs in ragged array  
   [data_vector, data_index] = create_indexed_column(ISIs, 'path');
   ISI_table = types.hdmf_common.DynamicTable(...
                    'colnames', 'ISIs',...
                    'description', 'ISI table',...
                    'id', types.hdmf_common.ElementIdentifiers('data', ...
                                           [0:length(data_vector.data)]) ,...
                    'ISIs', types.hdmf_common.VectorData(...
                                            'data', data_vector.data,...
                                            'description', 'Interspike Intervals'...
                                        ),...
                    'ISIs_index', types.hdmf_common.VectorIndex(...
                                            'data', data_index.data,...
                                            'target', types.untyped.ObjectView(...
                                              '/processing/All_ISIs/ISI_table/ISIs')...
                                                  )...
                                                    );
   module_ISIs.dynamictable.set('ISI_table', ISI_table);      
   cellFile.processing.set('All_ISIs', module_ISIs); 
   
   %% Feature Extraction and Summary
   if  ~isempty(cellFile.general_intracellular_ephys.values{1}.('initial_access_resistance')) && ...
           (string(cellFile.general_intracellular_ephys.values{1}.('initial_access_resistance')) ~= "NaN" && ...
               string(cellFile.general_intracellular_ephys.values{1}.('initial_access_resistance')) ~= ...
                   "has to be entered manually")
      
       if str2double(cellFile.general_intracellular_ephys.values{1}.('initial_access_resistance')) ...
                 <= params.cutoffInitRa && ...
          str2double(cellFile.general_intracellular_ephys.values{1}.('initial_access_resistance')) ...
                 <= Ri_preqc*params.factorRelaRa
       
       [cellFile, ICsummary, RheoSweepSeries, sagSweepSeries, RheoSweepTablePos, SagSweepTablePos] = ...
                  LPsummary(cellFile, ICsummary, n, params);
       plotCellProfile(RheoSweepSeries, sagSweepSeries, cellFile,...
            RheoSweepTablePos, SagSweepTablePos, outDest, params)
       %SP_summary
       else
           display([cellID, ' was excluded by cell-wide QC']);
      end              
   else
       [cellFile, ICsummary, RheoSweepSeries, sagSweepSeries, RheoSweepTablePos, SagSweepTablePos] = ...
                  LPsummary(cellFile, ICsummary, n, params);
       plotCellProfile(RheoSweepSeries, sagSweepSeries, cellFile,...
            RheoSweepTablePos, SagSweepTablePos, outDest, params)
       %SP_summary

   end    
      


   
   %% Export
   if overwrite == 1
      delete(fullfile(outDest, cellList(n).name)) 
   end    
   nwbExport(cellFile, fullfile(outDest, cellList(n).name));
end                                                                        % end cell level for loop

%% Cleaning up workspace

clear adaptIndex adaptIndex2 burst BwSweepParameter BwSweepPass c CCSeries ...
    CCStimSeries cell File cellID cvISI data_index data_vector ...
    delay diffV_b_e f gof holdingI i idx idxPassedSweeps instaRate ...
    instaRateCells  int4Peak ISI ISI_linVec ISI_table ISIs k key ...
    latency loc meanISI moduleISIs module_QC module_spike module_subStats ...
    peakAdapt peakAdapt2 QC_parameter QCpass restVPost restVPre RheoSweep ...
    Ri_preqc rmse_post rmse_post_st rmse_pre rmse_pre_st s sagSweep spTrain ...
    startInt4Peak StimOff StimOn stWin subCount subStats supraCount supraEvents ...
    sweepAmp SweepCount SweepIDsPassed table tau_vec val vec_pre vec_post ...
    vecin winCount x y yhat

%% Output summary fiels and figures 

Summary_output_files
QC_plots
QC_output_files


